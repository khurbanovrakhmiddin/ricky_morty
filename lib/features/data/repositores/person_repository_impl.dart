import 'package:dartz/dartz.dart';import 'package:ricky_morty/core/error/exeption.dart';import 'package:ricky_morty/core/error/failure.dart';import 'package:ricky_morty/core/platform/network_info.dart';import 'package:ricky_morty/features/data/datasources/person_local_datasouces.dart';import 'package:ricky_morty/features/data/datasources/person_remote_data_source.dart';import 'package:ricky_morty/features/domain/entities/person_entity.dart';import 'package:ricky_morty/features/domain/repository/person_repository.dart';import '../models/person_model.dart';class PersonRepositoryImpl implements PersonRepository {  final PersonRemoteDataSource remoteDataSource;  final PersonLocalDataSouces localDataSource;  final NetworkInfo networkInfo;  PersonRepositoryImpl({required this.remoteDataSource, required this.localDataSource, required this.networkInfo});  @override  Future<Either<Failure, List<PersonEntity>>> getAllPersons(int page) async {    return await _getPersons(() => remoteDataSource.getAllPersons(page));  }  @override  Future<Either<Failure, List<PersonEntity>>> searchPersons(String query) async {    return await _getPersons(() => remoteDataSource.searchPerson(query));  }  Future<Either<Failure, List<PersonModel>>> _getPersons(Future<List<PersonModel>> Function() getPerson) async {    if (await networkInfo.isConnected) {      try {        final remotePerson = await getPerson();        localDataSource.getToCache(remotePerson);        return Right(remotePerson);      } on ServerFailure {        return Left(ServerFailure());      }    } else {      try {        final localPerson = await localDataSource.getLastPersonsFromCache();        return Right(localPerson);      } on CacheExeption {        return Left(CacheFailure());      }    }  }}